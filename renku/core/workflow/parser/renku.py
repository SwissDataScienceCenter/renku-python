# -*- coding: utf-8 -*-
#
# Copyright 2018-2022 - Swiss Data Science Center (SDSC)
# A partnership between École Polytechnique Fédérale de Lausanne (EPFL) and
# Eidgenössische Technische Hochschule Zürich (ETHZ).
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Renku workflow file format parser."""

from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, Generator, List, Optional, Set, Tuple, Type, TypeVar, Union

from renku.core import errors
from renku.core.interface.workflow_file_parser import IWorkflowFileParser
from renku.core.plugin import hookimpl
from renku.core.util.os import get_absolute_path, get_relative_path, safe_read_yaml
from renku.core.workflow.workflow_file import BaseParameter, Input, Output, Parameter, Step, WorkflowFile
from renku.domain_model.project_context import project_context

BaseParameterType = TypeVar("BaseParameterType", bound=BaseParameter)


class RenkuWorkflowFileParser(IWorkflowFileParser):
    """Parser for Renku workflow files."""

    @hookimpl
    def workflow_file_parser(self) -> Tuple[IWorkflowFileParser, str]:
        """Workflow file parser name."""
        return self, "renku"

    @hookimpl
    def parse(self, path: Union[Path, str]) -> WorkflowFile:
        """Parse a given workflow file using the provider.

        Returns:
            WorkflowFile: A ``WorkflowFile`` generated by the provider.
        """
        data = safe_read_yaml(path=path)

        return convert_to_workflow_file(data=data, path=path)


def convert_to_workflow_file(data: Dict[str, Any], path: Union[Path, str]) -> WorkflowFile:
    """Create an instance of ``WorkflowFile``."""
    if not isinstance(data, dict):
        raise errors.ParseError("Workflow file must be a YAML dictionary")

    validate_attributes(
        kind="workflow file",
        name=None,
        data=data,
        valid_attributes={"name": str, "keywords": list, "description": str, "steps": (list, dict)},
        required_attributes={"name"},
    )

    try:
        path = get_absolute_path(path=path)
        relative_path = get_relative_path(path=path, base=project_context.path)
    except errors.ProjectContextError:
        relative_path = str(path)

    # NOTE: We always store the relative path (if available) in the WorkflowFile
    path = relative_path or path

    return WorkflowFile(
        path=path,
        name=data.get("name"),  # type: ignore
        description=data.get("description"),
        steps=[convert_to_step(data=e, path=path) for e in get_elements(data["steps"])],
        keywords=data.get("keywords"),
    )


def convert_to_step(data: Union[Dict[str, Any], str], path: Union[Path, str]) -> Step:
    """Create an instance of a workflow file ``Step``."""
    converted_data = convert_element(
        kind="step",
        data=data,
        valid_attributes={
            "command": str,
            "keywords": list,
            "description": str,
            "inputs": (dict, list),
            "outputs": (dict, list),
            "parameters": (dict, list),
            "success_codes": list,
        },
        required_attributes={"command"},
        allow_single_value=False,
    )

    assert isinstance(converted_data, dict)
    data = converted_data
    name = data["name"]

    return Step(
        name=name,
        command=data["command"],
        description=data.get("description"),
        inputs=[convert_to_base_parameter(Input, data=e) for e in get_elements(data.get("inputs", []))],
        outputs=[convert_to_base_parameter(Output, data=e) for e in get_elements(data.get("outputs", []))],
        parameters=[convert_to_base_parameter(Parameter, data=e) for e in get_elements(data.get("parameters", []))],
        path=path,
        keywords=data.get("keywords"),
    )


def convert_to_base_parameter(cls: Type[BaseParameterType], data: Union[Dict[str, Any], str]) -> BaseParameterType:
    """Create an instance of a workflow file ``Input``, ``Output``, or ``Parameter``."""
    valid_attributes: Dict[str, Any] = {"description": str, "prefix": str, "implicit": bool}

    if cls == Parameter:
        valid_attributes.update({"value": (str, int, float, bool)})
        required_attributes = {"value"}
    elif cls == Input:
        valid_attributes.update({"path": (str, int, float)})
        required_attributes = {"path"}
    else:
        assert cls == Output, f"Invalid parameter type: {cls}"
        valid_attributes.update({"path": (str, int, float), "persist": bool})
        required_attributes = {"path"}

    data = convert_element(
        kind=cls.__name__.lower(), data=data, valid_attributes=valid_attributes, required_attributes=required_attributes
    )

    if not isinstance(data, dict):
        data = {"value": data} if cls == Parameter else {"path": str(data)}
    elif cls in [Input, Output]:
        # NOTE: Path might be an int/float if user enters something like 123 as the path
        data["path"] = str(data.pop("path"))

    return cls(**data)


def get_elements(data: Union[Dict[str, Any], List[Dict[str, Any]]]) -> Generator[Dict[str, Any], None, None]:
    """Get elements of a list of dict as a dict."""
    if isinstance(data, list):
        for element in data:
            if isinstance(element, list):
                raise errors.ParseError(f"Data cannot be a list: {element}")
            yield element
    else:
        for key, value in data.items():
            yield {key: value}


def convert_element(
    kind: str,
    data: Union[Dict[str, Any], str],
    valid_attributes: Dict[str, Any],
    required_attributes: Set[str],
    allow_single_value: bool = True,
) -> Union[Dict[str, Any], str]:
    """Convert possible element definition formats to a dict format."""
    if isinstance(data, dict) and len(data) == 1:  # NOTE: <name>: {<properties>} format
        name, value = list(data.items())[0]
        validate_attributes(
            kind=kind, name=name, data=value, valid_attributes=valid_attributes, required_attributes=required_attributes
        )
        data = {"name": name}
        data.update(value)
        return data
    else:  # NOTE: List of inputs/outputs/parameters
        if not allow_single_value:
            raise errors.ParseError(f"Expected a dict with one value but got: {data}")
        if not isinstance(data, (str, int, float)):
            raise errors.ParseError(f"Expected string, integer, or floating-point type but got '{type(data)}': {data}")
        return str(data)


def validate_attributes(
    *, kind: str, name: Optional[str], data, valid_attributes: Dict[str, Any], required_attributes: Set[str]
):
    """Validate that the loaded yaml data is valid."""
    kind = f"{kind} '{name}'" if name else kind
    if valid_attributes:
        invalid_attributes = set(data.keys()) - set(valid_attributes)
        if invalid_attributes:
            invalid_attributes_str = ", ".join(sorted(invalid_attributes))
            raise errors.ParseError(f"Invalid attributes for {kind}: {invalid_attributes_str}")

        for attribute, valid_type in valid_attributes.items():
            if attribute not in data:
                continue
            if not isinstance(data[attribute], valid_type):
                valid_type_names = (
                    tuple(t.__name__ for t in valid_type) if isinstance(valid_type, tuple) else valid_type.__name__
                )
                raise errors.ParseError(
                    f"Invalid type for attribute '{attribute}' in {kind}: "
                    f"Required '{valid_type_names}' but got '{type(data[attribute]).__name__}'"
                )

    if required_attributes:
        for attribute in required_attributes:
            if attribute not in data:
                raise errors.ParseError(f"Required attribute '{attribute}' isn't set for {kind}: {data}")
